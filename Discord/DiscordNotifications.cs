using System.Net;
using Discord.WebSocket;

using GTRC_Basics.Models.DTOs;
using GTRC_Basics.Models;
using GTRC_Basics;
using GTRC_Database_Client.Responses;
using GTRC_Database_Client;

using bScripts = GTRC_Basics.Scripts;

namespace GTRC_Server_Basics.Discord
{
    public static class DiscordNotifications
    {
        private static readonly string pathPendingAutoRNrs = DiscordBot.DirectoryPendingNotifications + "entryIds auto-generated race-numbers.json";
        private static readonly string pathPendingIsNotScorer = DiscordBot.DirectoryPendingNotifications + "entryIds temporarily not scoring points.json";
        private static Dictionary<DiscordChannelType, ulong> ChannelIds = [];

        static DiscordNotifications()
        {
            _ = SetDiscordChannelIds(GlobalValues.NoId);
        }

        private static async Task SetDiscordChannelIds(int seriesId)
        {
            ChannelIds = new()
            {
                { DiscordChannelType.Log, GlobalValues.NoDiscordId },
                { DiscordChannelType.Registration, GlobalValues.NoDiscordId },
                { DiscordChannelType.TrackReport, GlobalValues.NoDiscordId }
            };
            if (seriesId != GlobalValues.NoId)
            {
                DbApiListResponse<SeriesDiscordchanneltype> respListSerDis = await DbApi.DynCon.SeriesDiscordchanneltype.GetChildObjects(typeof(Series), seriesId);
                foreach (SeriesDiscordchanneltype seriesDischatype in respListSerDis.List) { ChannelIds[seriesDischatype.DiscordChannelType] = seriesDischatype.DiscordId; }
            }
        }

        public static async Task ShowNewRegistrations(Season season, List<Entry> newEntries, bool forceUpdateEntryConflicts = false)
        {
            await SetDiscordChannelIds(season.SeriesId);
            await UpdateSeriesDiscordRolesAndNicknames(season);
            UniqPropsDto<SeriesDiscordchanneltype> uniqDtoSerDis = new()
            {
                Index = 0,
                Dto = new SeriesDiscordchanneltypeUniqPropsDto0() { DiscordChannelType = DiscordChannelType.Log, SeriesId = season.SeriesId }
            };
            DbApiObjectResponse<SeriesDiscordchanneltype> respSerDis = await DbApi.DynCon.SeriesDiscordchanneltype.GetByUniqProps(uniqDtoSerDis);
            if (respSerDis.Status == HttpStatusCode.OK)
            {
                string message = string.Empty;
                if (newEntries.Count > 0)
                {
                    message += "**Neue Anmeldungen " + season.Name + ":**";
                    foreach (Entry entry in newEntries)
                    {
                        DbApiObjectResponse<Entry> respEnt = await DbApi.DynCon.Entry.GetById(entry.Id);
                        if (respEnt.Status == HttpStatusCode.OK) { message += "\n- " + await AddEntryToDiscordMessage(entry); }
                        else { message += "\n- FEHLER: ENTRY NICHT IN DATENBANK GEFUNDEN!"; }
                    }
                    message += "\n\n";
                }
                List<Entry> entriesUpdatedRaceNumber = (await DbApi.DynCon.Entry.UpdateRaceNumbers(season.Id)).List;
                List<Entry> entriesPendingNotificaton = [];
                foreach (Entry entry in entriesUpdatedRaceNumber) { entriesPendingNotificaton.Add(entry); }
                foreach (Entry entry in newEntries)
                {
                    if (entry.RaceNumber != entry.RaceNumberPreference && !bScripts.ListContainsId(entriesPendingNotificaton, entry)) { entriesPendingNotificaton.Add(entry); }
                }
                _ = NotifyDriversAutoGeneratedRaceNumbers(entriesPendingNotificaton);
                if (entriesUpdatedRaceNumber.Count > 0)
                {
                    message += "**Aufgrund der neuen Anmeldungen nachträglich angepasste Startnummern:**";
                    foreach (Entry entry in entriesUpdatedRaceNumber) { message += "\n- " + await AddEntryToDiscordMessage(entry); }
                    message += "\n\n";
                }
                if (message.Length > 2) {  await DiscordCommands.DiscordBot.SendMessage(message[..^2], ChannelIds[DiscordChannelType.Log], DiscordMessageType.NewEntries); }
                if (message.Length > 2 || forceUpdateEntryConflicts) { await ShowSeasonSettingsViolations(season); }
                List<Event> listEvents = (await DbApi.DynCon.Event.GetChildObjects(typeof(Season), season.Id)).List;
                foreach (Event _event in listEvents) { await DbApi.DynCon.EventCar.UpdateBop(_event.Id); await DbApi.DynCon.EntryUserEvent.UpdateNames3Digits(_event.Id); }
            }
        }

        public static async Task UpdateSeriesDiscordRolesAndNicknames(Season season)
        {
            if (DiscordCommands.DiscordBot.Guild is not null)
            {
                SocketRole? driverRole = DiscordCommands.DiscordBot.Guild.GetRole(season.Series.DiscordDriverRoleId);
                if (driverRole is not null)
                {
                    List<SocketGuildUser> listDiscordUsers = [.. DiscordCommands.DiscordBot.Guild.Users];
                    foreach (SocketGuildUser discordUser in listDiscordUsers)
                    {
                        bool hasSeriesDriverRole = false;
                        IReadOnlyCollection<SocketRole> discordRoles = discordUser.Roles;
                        foreach (SocketRole role in discordRoles) { if (role.Id == driverRole.Id) { hasSeriesDriverRole = true; break; } }
                        DbApiObjectResponse<User> respObjUser = await DbApi.DynCon.User.GetByUniqProps(new() { Index = 1, Dto = new UserUniqPropsDto1() { DiscordId = discordUser.Id } });
                        if (respObjUser.Status == HttpStatusCode.OK && (await DbApi.DynCon.Entry.GetByUserSeason(respObjUser.Object.Id, season.Id)).List.Count > 0)
                        {
                            if (!hasSeriesDriverRole) { await discordUser.AddRoleAsync(driverRole.Id); }
                        }
                        else { if (hasSeriesDriverRole) { await discordUser.RemoveRoleAsync(driverRole.Id); } }
                        if (respObjUser.Status == HttpStatusCode.OK)
                        {
                            string fullName = UserFullDto.GetFullName(respObjUser.Object);
                            if (discordUser.Nickname != fullName) { try { await discordUser.ModifyAsync(property => property.Nickname = fullName); } catch { } }
                        }
                    }
                }
            }
        }

        public static async Task ShowSeasonSettingsViolations(Season season)
        {
            await SetDiscordChannelIds(season.SeriesId);
            string message = string.Empty;
            List<Entry> listEntries = (await DbApi.DynCon.Entry.GetAutoGeneratedRaceNumbers(season.Id)).List;
            if (listEntries.Count > 0)
            {
                message += "**Alle automatisch vergebenen Startnummern:**";
                foreach (Entry entry in listEntries) { message += "\n- " + await AddEntryToDiscordMessage(entry, true); }
                message += "\n\n";
            }
            List<User> listUsers = (await DbApi.DynCon.User.GetViolationsDiscordId(season.Id)).List;
            if (listUsers.Count > 0)
            {
                message += "**Fahrer ohne Discord-Id:**";
                foreach (User user in listUsers) { message += "\n- " + UserFullDto.GetFullName(user); }
                message += "\n\n";
            }
            listUsers = (await DbApi.DynCon.User.GetViolationsAllowEntriesShareDriverSameEvent(season.Id)).List;
            if (listUsers.Count > 0)
            {
                message += "**Am selben Event für mehrere Entries eingeschriebene Fahrer:**";
                foreach (User user in listUsers) { message += "\n- " + UserFullDto.GetFullName(user); }
                message += "\n\n";
            }
            listUsers = (await DbApi.DynCon.User.GetViolationsAllowEntriesShareDriver(season.Id)).List;
            if (listUsers.Count > 0)
            {
                message += "**Für mehrere Entries eingeschriebene Fahrer:**";
                foreach (User user in listUsers) { message += "\n- " + UserFullDto.GetFullName(user); }
                message += "\n\n";
            }
            listUsers = (await DbApi.DynCon.User.GetViolationsForceDriverFromOrganization(season.Id)).List;
            if (listUsers.Count > 0)
            {
                message += "**Für einen Entry eingeschriebene Fahrer, die nicht in dessen Organisation sind:**";
                foreach (User user in listUsers) { message += "\n- " + UserFullDto.GetFullName(user); }
                message += "\n\n";
            }
            listEntries = (await DbApi.DynCon.Entry.GetViolationsMinDriversPerEntryEvent(season.Id)).List;
            if (listEntries.Count > 0)
            {
                message += "**Entries mit weniger als " + season.MinDriversPerEntryEvent.ToString() + " Fahrer";
                if (season.MinDriversPerEntryEvent > 1) { message += "n"; }
                message += ":**";
                foreach (Entry entry in listEntries) { message += "\n- " + await AddEntryToDiscordMessage(entry); }
                message += "\n\n";
            }
            listEntries = (await DbApi.DynCon.Entry.GetViolationsMaxDriversPerEntryEvent(season.Id)).List;
            if (listEntries.Count > 0)
            {
                message += "**Entries mit mehr als " + season.MaxDriversPerEntryEvent.ToString() + " Fahrer";
                if (season.MaxDriversPerEntryEvent > 1) { message += "n"; }
                message += ":**";
                foreach (Entry entry in listEntries) { message += "\n- " + await AddEntryToDiscordMessage(entry); }
                message += "\n\n";
            }
            listEntries = (await DbApi.DynCon.Entry.GetViolationsAllowDriverLineupPerEvent(season.Id)).List;
            if (listEntries.Count > 0)
            {
                message += "**Entries mit wechselnden Fahrern:**";
                foreach (Entry entry in listEntries) { message += "\n- " + await AddEntryToDiscordMessage(entry); }
                message += "\n\n";
            }
            listEntries = (await DbApi.DynCon.Entry.GetViolationsDateStartRegistration(season.Id)).List;
            if (listEntries.Count > 0)
            {
                message += "**Anmeldungen vor dem " + bScripts.Date2String(season.DateStartRegistration.ToLocalTime(), "DD.MM.YY - hh:mm") + " Uhr:**";
                foreach (Entry entry in listEntries) { message += "\n- " + await AddEntryToDiscordMessage(entry, false, true); }
                message += "\n\n";
            }
            listEntries = (await DbApi.DynCon.Entry.GetViolationsDateEndRegistration(season.Id)).List;
            if (listEntries.Count > 0)
            {
                message += "**Anmeldungen nach dem " + bScripts.Date2String(season.DateEndRegistration.ToLocalTime(), "DD.MM.YY - hh:mm") + " Uhr:**";
                foreach (Entry entry in listEntries) { message += "\n- " + await AddEntryToDiscordMessage(entry, false, true); }
                message += "\n\n";
            }
            List<Team> listTeams = (await DbApi.DynCon.Team.GetViolationsMinEntriesPerTeam(season.Id)).List;
            if (listTeams.Count > 0)
            {
                message += "**Teams mit weniger als " + season.MinEntriesPerTeam.ToString();
                if (season.MinEntriesPerTeam == 1) { message += " Entry"; }
                else { message += " Entries"; }
                message += ":**";
                foreach (Team team in listTeams)
                {
                    message += "\n- " + team.Name + ":  ";
                    AddDto<Entry> addDto = new() { Dto = new EntryAddDto() { SeasonId = season.Id, TeamId = team.Id } };
                    listEntries = (await DbApi.DynCon.Entry.GetByProps(addDto)).List;
                    for (int entryIndex = 0; entryIndex < listEntries.Count; entryIndex++)
                    {
                        if (entryIndex > 0) { message += "  |  "; }
                        message += await AddEntryToDiscordMessage(listEntries[entryIndex]);
                    }
                }
                message += "\n\n";
            }
            listTeams = (await DbApi.DynCon.Team.GetViolationsMaxEntriesPerTeam(season.Id)).List;
            if (listTeams.Count > 0)
            {
                message += "**Teams mit mehr als " + season.MaxEntriesPerTeam.ToString();
                if (season.MaxEntriesPerTeam == 1) { message += " Entry"; }
                else { message += " Entries"; }
                message += ":**";
                foreach (Team team in listTeams)
                {
                    message += "\n- " + team.Name + ":  ";
                    AddDto<Entry> addDto = new() { Dto = new EntryAddDto() { SeasonId = season.Id, TeamId = team.Id } };
                    listEntries = (await DbApi.DynCon.Entry.GetByProps(addDto)).List;
                    for (int entryIndex = 0; entryIndex < listEntries.Count; entryIndex++)
                    {
                        if (entryIndex > 0) { message += "  |  "; }
                        message += await AddEntryToDiscordMessage(listEntries[entryIndex]);
                    }
                }
                message += "\n\n";
            }

            if (message.Length > 2) { await DiscordCommands.DiscordBot.SendMessage(message[..^2], ChannelIds[DiscordChannelType.Log], DiscordMessageType.SeasonSettingsViolations); }
            else
            {
                listEntries = (await DbApi.DynCon.Entry.GetChildObjects(typeof(Season), season.Id)).List;
                await DiscordCommands.DiscordBot.SendMessage("**" + season.Series.ToString() + " - " + season.Name + "**\n"
                    + "Anmeldungen: " + listEntries.Count.ToString() + "\n"
                    + "Offene Probleme: 0", ChannelIds[DiscordChannelType.Log], DiscordMessageType.SeasonSettingsViolations);
            }
        }

        public static async Task<string> AddEntryToDiscordMessage(Entry entry, bool showRaceNumberPreference = false, bool showRegisterDate = false)
        {
            string message = string.Empty;
            List<User> listUsers = (await DbApi.DynCon.User.GetByEntry(entry.Id)).List;
            message += "#" + entry.RaceNumber.ToString() + "  ";
            for (int userIndex = 0; userIndex < listUsers.Count; userIndex++)
            {
                if (userIndex > 0) { message += " & "; }
                message += UserFullDto.GetFullName(listUsers[userIndex]);
            }
            if (showRaceNumberPreference && entry.RaceNumber != entry.RaceNumberPreference) { message += "  |  Wunsch: #" + entry.RaceNumberPreference.ToString(); }
            if (showRegisterDate) { message += "  |  " + bScripts.Date2String(entry.RegisterDate.ToLocalTime(), "DD.MM.YY - hh:mm") + " Uhr"; }
            return message;
        }

        public static async Task NotifyDriversAutoGeneratedRaceNumbers(List<Entry> entriesAutoGeneratedRaceNumber)
        {
            List<int> entryIdsPending = DiscordBot.LoadEntryIdList(pathPendingAutoRNrs);
            foreach (Entry entry in entriesAutoGeneratedRaceNumber) { entryIdsPending = await NotifyDriversAutoGeneratedRaceNumber(entry, entryIdsPending); }
            for (int entryIndex = entryIdsPending.Count - 1; entryIndex >= 0; entryIndex--)
            {
                DbApiObjectResponse<Entry> respObjEntry = await DbApi.DynCon.Entry.GetById(entryIdsPending[entryIndex]);
                if (respObjEntry.Status == HttpStatusCode.OK) { entryIdsPending = await NotifyDriversAutoGeneratedRaceNumber(respObjEntry.Object, entryIdsPending); }
                else { if (entryIdsPending.Remove(entryIdsPending[entryIndex])) { DiscordBot.SaveEntryIdList(pathPendingAutoRNrs, entryIdsPending); } }
            }
        }

        private static async Task<List<int>> NotifyDriversAutoGeneratedRaceNumber(Entry entry, List<int> entryIdsPending)
        {
            UniqPropsDto<Entry> uniqPropsDto = new() { Dto = new EntryUniqPropsDto0 { SeasonId = entry.SeasonId, RaceNumber = entry.RaceNumberPreference } };
            DbApiObjectResponse<Entry> respObjEntryPrioritized = await DbApi.DynCon.Entry.GetByUniqProps(uniqPropsDto);
            if (respObjEntryPrioritized.Status == HttpStatusCode.OK && respObjEntryPrioritized.Object.Id != entry.Id && entry.RaceNumberPreference != entry.RaceNumber)
            {
                List<User> listDrivers = (await DbApi.DynCon.User.GetByEntry(entry.Id)).List;
                List<User> listDriversPrioritized = (await DbApi.DynCon.User.GetByEntry(respObjEntryPrioritized.Object.Id)).List;
                List<ulong> driverIds = [];
                foreach (User driver in listDrivers) { if (driver.DiscordId != GlobalValues.NoDiscordId) { driverIds.Add(driver.DiscordId); } }
                if (driverIds.Count > 0)
                {
                    NotifyDriversAutoGeneratedRaceNumber(entry, driverIds, listDrivers, respObjEntryPrioritized.Object, listDriversPrioritized);
                    if (entryIdsPending.Remove(entry.Id)) { DiscordBot.SaveEntryIdList(pathPendingAutoRNrs, entryIdsPending); }
                }
                else { if (!entryIdsPending.Contains(entry.Id)) { entryIdsPending.Add(entry.Id); DiscordBot.SaveEntryIdList(pathPendingAutoRNrs, entryIdsPending); } }
            }
            return entryIdsPending;
        }

        private static void NotifyDriversAutoGeneratedRaceNumber(Entry entry, List<ulong> driverIds, List<User> listDrivers, Entry entryPrioritized, List<User> listDriversPrioritized)
        {
            if (driverIds.Count > 0)
            {
                string message = DiscordBot.GetTagsByDiscordIds(driverIds) + " Leider ist ";
                if (listDrivers.Count > 1) { message += "eure"; } else { message += "deine"; }
                message += " erwünschte Startnummer aktuell für #" + entry.RaceNumberPreference.ToString() + " " + entryPrioritized.Team.Name;
                for (int userIndex = 0; userIndex < listDriversPrioritized.Count; userIndex++)
                {
                    if (userIndex == 0) { message += " ("; } else { message += " & "; }
                    message += UserFullDto.GetFullName(listDriversPrioritized[userIndex]);
                }
                if (listDriversPrioritized.Count > 0) { message += ")"; }
                message += " reserviert. Daher ist ";
                if (listDrivers.Count > 1) { message += "eure"; } else { message += "deine"; }
                message += " neue Startnummer vorläufig die #" + entry.RaceNumber.ToString() + ". ";
                if (listDrivers.Count > 1) { message += "Ihr könnt euch"; } else { message += "Du kannst dir"; }
                message += " mit dem Befehl `!Startnummer 0` gerne eine neue Startnummer wünschen.";
                _ = DiscordCommands.DiscordBot.SendMessage(message, ChannelIds[DiscordChannelType.Registration], DiscordMessageType.PermanentInfo);
            }
        }

        public static async Task ShowEntrylist(Event _event, bool showCars = false)
        {
            await SetDiscordChannelIds(_event.Season.SeriesId);


            //Placeholder
            int slotsTakenTotal = 0;
            int slotsAvailableTotal = _event.Track.ServerSlotsCount;
            List<EntryEvent> listEntriesEvents = [];
            List<Entry> listEntries = (await DbApi.DynCon.Entry.GetChildObjects(typeof(Season), _event.SeasonId)).List;
            List<Event> listEvents = Scripts.SortByDate((await DbApi.DynCon.Event.GetChildObjects(typeof(Season), _event.SeasonId)).List);
            foreach (Entry entry in listEntries)
            {
                EntryEventUniqPropsDto0 dto = new() { EntryId = entry.Id, EventId = _event.Id };
                EntryEvent entryEvent = (await DbApi.DynCon.EntryEvent.GetAnyByUniqProps(dto)).Object;
                if (EntryEventFullDto.GetRegisterState(entryEvent) && EntryEventFullDto.GetSignInState(entryEvent)) { slotsTakenTotal++; }
                listEntriesEvents.Add(entryEvent);
            }
            for (int index1 = 0; index1 < listEntriesEvents.Count - 1; index1++)
            {
                for (int index2 = index1 + 1; index2 < listEntriesEvents.Count; index2++)
                {
                    if (listEntriesEvents[index1].Entry.RaceNumber > listEntriesEvents[index2].Entry.RaceNumber)
                    {
                        (listEntriesEvents[index1], listEntriesEvents[index2]) = (listEntriesEvents[index2], listEntriesEvents[index1]);
                    }
                }
            }
            //Placeholder
            string message = "**Starterfeld für Event " + _event.Name + Scripts.Date2String(_event.Date, " (DD.MM.YY)") + " | " +
                slotsTakenTotal.ToString() + "/" + slotsAvailableTotal.ToString() + "**\n";
            string newMessagePart = "";
            uint pos = 1;
            foreach (EntryEvent entryEvent in listEntriesEvents)
            {
                if (EntryEventFullDto.GetRegisterState(entryEvent) && EntryEventFullDto.GetSignInState(entryEvent))
                {
                    (newMessagePart, pos) = await AddLineEntrylist(newMessagePart, pos, entryEvent, true, showCars);
                }
            }
            if (pos > 1) { message += newMessagePart; } else { message += "-\n"; }

            newMessagePart = "";
            pos = 1;
            foreach (EntryEvent entryEvent in listEntriesEvents)
            {
                if (EntryEventFullDto.GetRegisterState(entryEvent) && !EntryEventFullDto.GetSignInState(entryEvent))
                {
                    (newMessagePart, pos) = await AddLineEntrylist(newMessagePart, pos, entryEvent, true, showCars);
                }
            }
            if (pos > 1) { message += "\n**Abmeldungen (" + (pos - 1).ToString() + ")**\n" + newMessagePart; }

            newMessagePart = "";
            pos = 1;
            foreach (EntryEvent entryEvent in listEntriesEvents)
            {
                if (!EntryEventFullDto.GetRegisterState(entryEvent) && listEvents.Count > 0 && entryEvent.Entry.SignOutDate > listEvents[0].Date)
                {
                    (newMessagePart, pos) = await AddLineEntrylist(newMessagePart, pos, entryEvent, true, showCars);
                }
            }
            if (pos > 1) { message += "\n**Aus der Meisterschaft zurückgezogen (" + (pos - 1).ToString() + ")**\n" + newMessagePart; }


            /*
            bool isBanned = false;
            foreach (User user in listUsers)
            {
                if (user.BanDate < entryEvent.Event.Date) { isBanned = true; }
                else
                {
                    DbApiObjectResponse<UserDatetime> respObjDriDat = await DbApi.DynCon.UserDatetime.GetAnyByUniqProps(new() { UserId = user.Id, Date = entryEvent.Event.Date });
                    if (respObjDriDat.Status != HttpStatusCode.OK || respObjDriDat.Object.SafetyRating <= 0) { isBanned = true; }
                }
            }*/
            await DiscordCommands.DiscordBot.SendMessage(message, ChannelIds[DiscordChannelType.Registration], DiscordMessageType.Entries);
        }

        public static async Task<(string, uint)> AddLineEntrylist(string message, uint pos, EntryEvent entryEvent,
            bool showCar = false, bool showCarChangeCount = false, bool showPos = false, bool isBanned = false)
        {
            Entry entry = entryEvent.Entry;
            List<User> listUsers = (await DbApi.DynCon.User.GetByEntry(entry.Id)).List;
            Car? car = null;
            DbApiObjectResponse<EntryDatetime> respObjEntDat = await DbApi.DynCon.EntryDatetime.GetAnyByUniqProps(new() { EntryId = entry.Id, Date = entryEvent.Event.Date });
            if (respObjEntDat.Status == HttpStatusCode.OK) { car = respObjEntDat.Object.Car; }

            if (showPos) { message += pos.ToString() + ".  "; }
            message += "#" + entry.RaceNumber.ToString() + "  ";
            for (int index = 0; index < listUsers.Count; index++)
            {
                if (index > 0) { message += ", "; }
                message += UserFullDto.GetFullName(listUsers[index]);
            }
            if (showCar && car is not null) { message += "  -  " + car.Name; }
            if (showCarChangeCount && entry.IsPointScorer && entry.Season.CarChangeLimit < byte.MaxValue && entry.Season.DateStartCarChangeLimit < GlobalValues.DateTimeMaxValue)
            {
                byte? carChangeCount = (await DbApi.DynCon.Entry.GetCarChangeCount(entry.Id, entryEvent.EventId)).Value;
                if (carChangeCount is not null)
                {
                    if (carChangeCount >= entry.Season.CarChangeLimit) { message += " - **" + carChangeCount.ToString() + "/" + entry.Season.CarChangeLimit.ToString() + "**"; }
                    else { message += " - " + carChangeCount.ToString() + "/" + entry.Season.CarChangeLimit.ToString(); }
                }
            }
            if (!entryEvent.IsPointScorer)
            {
                message += " | *außer Wertung";
                if (entry.IsPointScorer) { message += " (wg. Fzglimit)"; }
                else
                {
                    List<Event> listEvents = bScripts.SortByDate((await DbApi.DynCon.Event.GetChildObjects(typeof(Season), entry.SeasonId)).List);
                    if (listEvents.Count > 0)
                    {
                        DbApiObjectResponse<EntryEvent> respObjEntEve = await DbApi.DynCon.EntryEvent.GetAnyByUniqProps(new() { EntryId = entry.Id, EventId = listEvents[0].Id });
                        if (respObjEntEve.Status == HttpStatusCode.OK && respObjEntEve.Object.IsPointScorer)
                        {
                            byte? noShowsCount = (await DbApi.DynCon.EntryEvent.GetNoShowsCount(entry.Id, entryEvent.EventId)).Value;
                            if (noShowsCount is not null && noShowsCount > entry.Season.MaxNoShows) { message += " (wg. Abw. trotz Anm.)"; }
                        }
                    }
                }
                message += "*";
            }
            if (isBanned) { message += " | **GESPERRT**"; }
            message += "\n";
            pos++;
            return (message, pos);
        }

        public static async Task ShowBop(Season season, Event _event)
        {
            await SetDiscordChannelIds(season.SeriesId);
            string message = "Keine BoP für das Event " + _event.Name + bScripts.Date2String(_event.Date, " (DD.MM.YY") + ") gefunden.";
            List<EventCar> listEventsCars = (await DbApi.DynCon.EventCar.UpdateBop(_event.Id)).List;
            if (listEventsCars.Count > 0)
            {
                for (int index1 = 0; index1 < listEventsCars.Count - 1; index1++)
                {
                    for (int index2 = index1 + 1; index2 < listEventsCars.Count; index2++)
                    {
                        if (listEventsCars[index1].CountBop == listEventsCars[index2].CountBop)
                        {
                            if (listEventsCars[index1].Count == listEventsCars[index2].Count)
                            {
                                if (String.Compare(listEventsCars[index1].Car.Name, listEventsCars[index2].Car.Name) > 0)
                                {
                                    (listEventsCars[index1], listEventsCars[index2]) = (listEventsCars[index2], listEventsCars[index1]);
                                }
                            }
                            else if (listEventsCars[index1].Count < listEventsCars[index2].Count)
                            {
                                (listEventsCars[index1], listEventsCars[index2]) = (listEventsCars[index2], listEventsCars[index1]);
                            }
                        }
                        else if (listEventsCars[index1].CountBop < listEventsCars[index2].CountBop)
                        {
                            (listEventsCars[index1], listEventsCars[index2]) = (listEventsCars[index2], listEventsCars[index1]);
                        }
                    }
                }
                message = "**BoP für Event " + _event.Name + bScripts.Date2String(_event.Date, " (DD.MM.YY)**\n");
                foreach (EventCar eventCar in listEventsCars)
                {
                    if (eventCar.CountBop > 0)
                    {
                        message += eventCar.Count.ToString() + "x    ";
                        if (eventCar.BallastKg > 0) { message += "+"; }
                        message += eventCar.BallastKg.ToString() + " kg    ";
                        //message += eventCar.Restrictor.ToString() + "%  ";
                        message += eventCar.Car.Name;
                        if (_event.Season.DateBoPFreeze < _event.Date && eventCar.Count != eventCar.CountBop)
                        {
                            message += "    " + eventCar.CountBop.ToString() + "x am " +
                                bScripts.Date2String(_event.Season.DateBoPFreeze.ToLocalTime(), "DD.MM.YY") + " um " +
                                bScripts.Date2String(_event.Season.DateBoPFreeze.ToLocalTime(), "hh:mm") + " Uhr";
                        }
                        message += "\n";
                    }
                }
            }
            await DiscordCommands.DiscordBot.SendMessage(message, ChannelIds[DiscordChannelType.Registration], DiscordMessageType.BoP);
        }

        public static async Task ShowEvents(Season season, ulong channelId, List<Event> listEvents)
        {
            listEvents = bScripts.SortByDate(listEvents);
            string message = "**Rennkalender " + season.Name + "**\n";
            int preQualiNr = 1;
            int eventNr = 1;
            for (int index = 0; index < listEvents.Count; index++)
            {
                if (listEvents[index].IsPreQualifying)
                {
                    TimeSpan totalDuration = TimeSpan.FromMinutes(0);
                    DbApiListResponse<Session> respListSes = await DbApi.DynCon.Session.GetChildObjects(typeof(Event), listEvents[index].Id);
                    if (respListSes.Status == HttpStatusCode.OK)
                    {
                        foreach (Session session in respListSes.List)
                        {
                            TimeSpan duration = TimeSpan.FromMinutes((session.DurationMin * session.SessionsCount) + session.StartTimeOffsetMin);
                            if (duration > totalDuration) { totalDuration = duration; }
                        }
                    }
                    message += bScripts.Date2String(listEvents[index].Date.ToLocalTime(), "DD.MM.") + " - ";
                    message += bScripts.Date2String((listEvents[index].Date + totalDuration).ToLocalTime(), "DD.MM.");
                    message += "  Vorqualifikation #" + preQualiNr.ToString();
                    message += "  " + listEvents[index].Track.Name + "\n";
                    preQualiNr++;
                }
                else
                {
                    message += eventNr.ToString() + ".  ";
                    message += bScripts.Date2String(listEvents[index].Date.ToLocalTime(), "DD.MM.");
                    message += "  " + listEvents[index].Track.Name + "\n";
                    eventNr++;
                }
            }
            _ = DiscordCommands.DiscordBot.SendMessage(message, channelId, DiscordMessageType.Events);
        }

        public static async Task ShowCars(Season season, ulong channelId, bool userIsAdmin)
        {
            DbApiListResponse<Car> respObjCar = await DbApi.DynCon.Car.GetAll();
            for (int index1 = 0; index1 < respObjCar.List.Count - 1; index1++)
            {
                for (int index2 = index1 + 1; index2 < respObjCar.List.Count; index2++)
                {
                    if (String.Compare(respObjCar.List[index1].Name, respObjCar.List[index2].Name) > 0)
                    {
                        (respObjCar.List[index1], respObjCar.List[index2]) = (respObjCar.List[index2], respObjCar.List[index1]);
                    }
                }
            }
            List<Carclass> listValidCarclasses = (await DbApi.DynCon.Carclass.GetBySeason(season.Id)).List;
            string message = "**Fahrzeugliste**\n";
            foreach (Car car in respObjCar.List)
            {
                bool isValidCarclass = false;
                foreach (Carclass carclass in listValidCarclasses) { if (car.Carclass.Id == carclass.Id) { isValidCarclass = true; break; } }
                DbApiObjectResponse<EventCar> respObjEveCar = new();
                DbApiObjectResponse<Event> respObjNextEvent = await DbApi.DynCon.Event.GetNext(season.Id);
                DbApiValueResponse<bool> respValIsLatestModel = await DbApi.DynCon.Car.GetIsLatestModel(car.Id);
                if (respObjNextEvent.Status == HttpStatusCode.OK)
                {
                    UniqPropsDto<EventCar> uniqPropsDto = new() { Dto = new EventCarUniqPropsDto0 { CarId = car.Id, EventId = respObjNextEvent.Object.Id } };
                    respObjEveCar = await DbApi.DynCon.EventCar.GetByUniqProps(uniqPropsDto);
                }
                if (isValidCarclass && (userIsAdmin || (respValIsLatestModel.Value ?? false)))
                {
                    message += "#" + car.AccCarId.ToString() + "  -  ";
                    message += car.Name;
                    message += " (" + car.Year.ToString() + ")";
                    if (respObjEveCar.Status == HttpStatusCode.OK && respObjEveCar.Object.CountBop > 0)
                    {
                        message += " - " + respObjEveCar.Object.CountBop.ToString();
                        if (season.CarRegistrationLimit < byte.MaxValue) { message += "/" + season.CarRegistrationLimit.ToString(); }
                        else { message += "x"; }
                    }
                    message += "\n";
                }
            }
            _ = DiscordCommands.DiscordBot.SendMessage(message, channelId, DiscordMessageType.Cars);
        }

        public static async Task ShowOrganizations(Season season, ulong channelId, List<Organization> listOrganizations, bool userIsAdmin)
        {
            string message = string.Empty;
            foreach (Organization organization in listOrganizations)
            {
                message += "\n\n**Organisation:  " + organization.Name + "**\n";
                message += "\n**Mitglieder:**\n";
                List<OrganizationUser> listOrgaUser = (await DbApi.DynCon.OrganizationUser.GetChildObjects(typeof(Organization), organization.Id)).List;
                for (int index1 = 0; index1 < listOrgaUser.Count - 1; index1++)
                {
                    for (int index2 = index1 + 1; index2 < listOrgaUser.Count; index2++)
                    {
                        if (listOrgaUser[index1].IsAdmin == listOrgaUser[index2].IsAdmin)
                        {
                            if (listOrgaUser[index1].IsInvited == listOrgaUser[index2].IsInvited)
                            {
                                if (String.Compare(listOrgaUser[index1].User.LastName, listOrgaUser[index2].User.LastName) > 0)
                                {
                                    (listOrgaUser[index1], listOrgaUser[index2]) = (listOrgaUser[index2], listOrgaUser[index1]);
                                }
                            }
                            else if (listOrgaUser[index1].IsInvited)
                            {
                                (listOrgaUser[index1], listOrgaUser[index2]) = (listOrgaUser[index2], listOrgaUser[index1]);
                            }
                        }
                        else if (listOrgaUser[index2].IsAdmin)
                        {
                            (listOrgaUser[index1], listOrgaUser[index2]) = (listOrgaUser[index2], listOrgaUser[index1]);
                        }
                    }
                }
                foreach (OrganizationUser orgaUser in listOrgaUser)
                {
                    message += "- " + UserFullDto.GetFullName(orgaUser.User);
                    if (orgaUser.IsAdmin) { message += "  (Admin)"; }
                    else if (orgaUser.IsInvited) { message += "  (Einladung noch nicht angenommen)"; }
                    message += "\n";
                }
                message += "\n**Teams:**\n";
                List<Team> listTeams = (await DbApi.DynCon.Team.GetChildObjects(typeof(Organization), organization.Id)).List;
                for (int index1 = 0; index1 < listTeams.Count - 1; index1++)
                {
                    for (int index2 = index1 + 1; index2 < listTeams.Count; index2++)
                    {
                        if (String.Compare(listTeams[index1].Name, listTeams[index2].Name) > 0)
                        {
                            (listTeams[index1], listTeams[index2]) = (listTeams[index2], listTeams[index1]);
                        }
                    }
                }
                List<Entry> listEntries = [];
                foreach (Team team in listTeams)
                {
                    message += "- #" + team.Id.ToString() + "  -  " + team.Name + "\n";
                    List<Entry> listEntriesTemp = (await DbApi.DynCon.Entry.GetChildObjects(typeof(Team), team.Id)).List;
                    foreach (Entry entry in listEntriesTemp)
                    {
                        if (!bScripts.ListContainsId(listEntries, entry) && (userIsAdmin || entry.SeasonId == season.Id)) { listEntries.Add(entry); }
                    }
                }
                for (int index1 = 0; index1 < listEntries.Count - 1; index1++)
                {
                    for (int index2 = index1 + 1; index2 < listEntries.Count; index2++)
                    {
                        if (listEntries[index1].SeasonId == listEntries[index2].SeasonId)
                        {
                            if (listEntries[index1].RaceNumber == listEntries[index2].RaceNumber)
                            {
                                if (String.Compare(listEntries[index1].Team.Name, listEntries[index2].Team.Name) > 0)
                                {
                                    (listEntries[index1], listEntries[index2]) = (listEntries[index2], listEntries[index1]);
                                }
                            }
                            else if (listEntries[index1].RaceNumber > listEntries[index2].RaceNumber)
                            {
                                (listEntries[index1], listEntries[index2]) = (listEntries[index2], listEntries[index1]);
                            }
                        }
                        else if (listEntries[index1].SeasonId > listEntries[index2].SeasonId)
                        {
                            (listEntries[index1], listEntries[index2]) = (listEntries[index2], listEntries[index1]);
                        }
                    }
                }
                if (listEntries.Count > 0)
                {
                    message += "\n**Teilnahmen";
                    if (!userIsAdmin) { message += " " + season.Series.Name + " " + season.Name; }
                    message += ":**\n";
                    foreach (Entry entry in listEntries)
                    {
                        message += "- ";
                        if (userIsAdmin) { message += entry.Season.Series.Name + " " + entry.Season.Name + ":  "; }
                        message += "#" + entry.RaceNumber.ToString() + " " + entry.Team.Name + "  |  ";
                        List<User> listUsers = (await DbApi.DynCon.User.GetByEntry(entry.Id)).List;
                        for (int index = 0; index < listUsers.Count; index++)
                        {
                            if (index > 0) { message += ", "; }
                            message += UserFullDto.GetShortName(listUsers[index]);
                        }
                        message += "\n";
                    }
                }
            }
            await DiscordCommands.DiscordBot.SendMessage(message, channelId, DiscordMessageType.Organizations);
        }

        public static async Task ShowEloRating(ulong channelId, UserDatetime userDatetime)
        {
            string message = "Fahrer: " + UserFullDto.GetFullName(userDatetime.User);
            message += "\nELO-Rating: " + userDatetime.EloRating.ToString();
            await DiscordCommands.DiscordBot.SendMessage(message, channelId, DiscordMessageType.Rating);
        }

        public static async Task ShowSafetyRating(ulong channelId, UserDatetime userDatetime)
        {
            string message = "Fahrer: " + UserFullDto.GetFullName(userDatetime.User);
            message += "\nSafety-Rating: " + userDatetime.SafetyRating.ToString();
            await DiscordCommands.DiscordBot.SendMessage(message, channelId, DiscordMessageType.Rating);
        }

        public static async Task ShowWarningsCount(ulong channelId, UserDatetime userDatetime)
        {
            string message = "Fahrer: " + UserFullDto.GetFullName(userDatetime.User);
            message += "\nVerwarnungen: " + userDatetime.Warnings.ToString();
            await DiscordCommands.DiscordBot.SendMessage(message, channelId, DiscordMessageType.Rating);
        }
    }
}
